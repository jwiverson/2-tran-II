#Construct a double cover of Sp(6,2) from the Atlas
Gast:=AtlasGroup("2.S6(2)");;

#Create the quotient by the center
hom:=NaturalHomomorphismByNormalSubgroup(Gast,Center(Gast));;
g:=Image(hom);;

#Get the doubly transitive representation of Sp(6,2) on 36 points
G:=PrimitiveGroup(36,10);;

#Construct an isomorphism between the quotient g and the permutation group G
#(This simultaneously verifies that Gast is the Schur cover)
iso:=IsomorphismGroups(g,G);;
pi:=CompositionMapping(iso,hom);;

#Find the stabilizer of a point and its preimage under the covering map
G0:=Stabilizer(G,1);;
G0ast:=PreImage(pi,G0);;

#Get the linear characters of G0ast
lin:=LinearCharacters(G0ast);;



#Make a program to test the linear characters
RadIsHP:=function(Gast,G0ast,alpha)
	#Input:		A group Gast which is a Schur cover of a 2-transitive group G,
	#		a subgroup G0ast which is the inverse image of a point
	#		stabilizer in G, and a linear character alpha of G0ast.
	#Output:	True, if the radicalization of (Gast,G0ast,alpha) is a Higman
	#		pair. Otherwise, false.
	#Note:		This function implements the "Higman Pair Detector" described
	#		in the paper "Doubly transitive lines II: Almost simple
	#		symmetries", by J.W. Iverson and D.G. Mixon.

	local x,ker,result,xi;

	#find x in Gast but not G0ast
	x:=Random(Gast);
	while x in G0ast do
		x:=Random(Gast);
	od;

	ker:=KernelOfCharacter(alpha);

	result:=true;

	for xi in G0ast do
		if not(x*xi*x^(-1) in G0ast) then
			continue;
		fi;

		if not(x*xi*x^(-1)*xi^(-1) in ker) then
			result:=false;
			break;
		fi;
	od;

	return result;
end;;


#Make a program to compute the roux parameters for radicalizations
RadRouxParams:=function(Gast,G0ast,alpha)
	#Input:		A group Gast which is a Schur cover of a 2-transitive group G,
	#		a subgroup G0ast which is the inverse image of a point
	#		stabilizer in G, and a linear character alpha of G0ast for which
	#		the radicalization of (Gast,G0ast,alpha) is a Higman Pair.
	#Output:	The roux parameters, expressed as a list c of pairs [z,c_z],
	#		where z belongs to the group generated by E(r) and r is twice
	#		the size of the image of alpha.
	#Note:		This function implements the "Roux from Higman Pairs" lemma
	#		of "Doubly transitive lines I: Higman pairs and roux",
	#		by J.W. Iverson and D.G. Mixon.
	#Note:		Repeated calls to this function might return slightly different
	#		parameters. This is because the roux parameters are taken
	#		with respect to a key for the Higman pair. The function uses
	#		a random procedure to find a key as in the "key finder" lemma,
	#		so the results vary from use to use. However, no matter how the
	#		key is chosen, the Fourier transform of the roux parameters will
	#		always provide the same dimensions of the resulting 2-transitive
	#		lines. This is because those dimensions are the ranks of the
	#		primitive idempotents in the roux scheme, and those ranks are
	#		ambivalent to our labeling of one of the adjecency matrices as
	#		corresponding to a "key".

	local n,r,x,G0ast2,proj1,proj2,dcstAction,pair,xi,eta,k,z,Cr,er,GastTil,G0astTil,em1,em2,p1,p2,gensG0ast,gensH,zeta,dict,w,j,dcst,count,el,c,H;

	r:=2*Size(AsSet(ValuesOfClassFunction(alpha)));

	n:=Size(Gast)/Size(G0ast);

	#find x in Gast but not G0ast
	x:=Random(Gast);
	while x in G0ast do
		x:=Random(Gast);
	od;

	#make the action of G0ast x G0ast on Gast whose orbits are the double cosets
	G0ast2:=DirectProduct(G0ast,G0ast);
	proj1:=Projection(G0ast2,1);
	proj2:=Projection(G0ast2,2);
	dcstAction:=function(y,pair)
		#Input:		An element y of Gast and an element pair of G0ast2,
		#		where pair corresponds to (xi,eta).
		#Output:	xi^(-1)*y*eta, as in the (right) action of G0ast x G0ast
		#		on G0.

		local xi,eta;

		xi:=Image(proj1,pair);
		eta:=Image(proj2,pair);
		return xi^(-1)*y*eta;

	end;

	#find a key for the radicalization, as in the "key finder" lemma
	pair:=RepresentativeAction(G0ast2,x,x^(-1),dcstAction);
	xi:=Image(proj1,pair)^(-1);
	eta:=Image(proj2,pair);

	for k in [0..r-1] do
		if E(r)^(2*k) = (xi*eta)^alpha then
			z:=E(r)^k;
			break;
		fi;
	od;

	#now b=(x,z) is a key for the Higman pair
	
	
	#make the product of Gast with C(r)
	Cr:=CyclicGroup(IsPermGroup,r);
	er:=MinimalGeneratingSet(Cr)[1]; #it will take the role of E(r)
	GastTil:=DirectProduct(Gast,Cr);
	em1:=Embedding(GastTil,1);
	em2:=Embedding(GastTil,2);
	p1:=Projection(GastTil,1);
	p2:=Projection(GastTil,2);

	#make H = { (zeta, alpha(zeta)^(-1)) : zeta in G0ast }
	gensG0ast:=GeneratorsOfGroup(G0ast);
	gensH:=[];
	for zeta in gensG0ast do
		#find which power of E(r) gives alpha(zeta)^(-1)
		for k in [0..r-1] do
			if E(r)^k = Inverse(zeta)^alpha then
				break;
			fi;
		od;
		
		#add a corresponding generator for H
		Add(gensH,Image(em1,zeta)*Image(em2,er^k));
	od;
	H:=Subgroup(GastTil,gensH);

	#make a dictionary whose keys are the elements w of < E(r) >, and
	#which stores pairs [dcst,count] where dcst is a double coset
	#of H in GastTil corresponding to w and count is the number of intersections
	#between dcst and bHb^(-1) observed so far

	dict:=NewDictionary(E(r),true);

	for k in [0..r-1] do
		w:=E(r)^k;

		#find the power of E(r) that gives z*w
		for j in [0..r-1] do
			if E(r)^j = w*z then
				break;
			fi;
		od;

		dcst:=DoubleCoset(H,Image(em1,x)*Image(em2,er^j),H);
		count:=0;
		AddDictionary(dict,w,[dcst,count]);
	od;

	#iterate through bHb^(-1) and count how many elements hit each of the double cosets
	for zeta in G0ast do
		#find j for which alpha(zeta)^(-1) = E(r)^j
		for j in [0..r-1] do
			if E(r)^j = Inverse(zeta)^alpha then
				break;
			fi;
		od;

		#make the element of bHb^(-1) corresponding to zeta
		el:=Image(em1,x*zeta*x^(-1))*Image(em2,er^j);

		for k in [0..r-1] do
			w:=E(r)^k;
			pair:=LookupDictionary(dict,w);
			dcst:=pair[1];
			count:=pair[2];
			if el in dcst then
				pair[2]:=count+1;
				break;
			fi;
		od;
	od;
	
	#return the roux parameters
	c:=[];
	for k in [0..r-1] do
		w:=E(r)^k;
		pair:=LookupDictionary(dict,w);
		count:=pair[2];
		Add(c,[w,(n-1)/Size(G0ast)*count]);
	od;

	return c;
end;;


#make a program to convert roux parameters to ETF parameters
RadETFParams:=function(Gast,G0ast,alpha)
	#Input:		A group Gast which is a Schur cover of a 2-transitive group G,
	#		a subgroup G0ast which is the inverse image of a point
	#		stabilizer in G, and a linear character alpha of G0ast for which
	#		the radicalization of (Gast,G0ast,alpha) is a Higman Pair.
	#Output:	A list of the ETF parameters [d,n] for all doubly transitive lines
	#		corresponding to the primitive idempotents of the roux scheme.
	#		The final element of this list is "true" if all the ETFs can be
	#		taken to be real, and "false" if at least one is not real.

	local c,n,r,cHat,k,z,result,pair,eps,mu,d,real,w;

	c:=RadRouxParams(Gast,G0ast,alpha);

	n:=Sum(List(c,pair->pair[2]))+2;

	r:=Size(c);

	#find the Fourier transform of c
	cHat:=[];
	for k in [0..r-1] do
		z:=Sum(List(c,pair->pair[1]^k*pair[2]));
		Add(cHat,[k,z]);
	od;

	#iterate through cHat and give the resulting ETF parameters
	result:=[];

	for pair in cHat do
		k:=pair[1];
		z:=pair[2];
		for eps in [1,-1] do
			mu:=(z+eps*Sqrt(z^2+4*(n-1)))/2/(n-1);
			d:=n/(1+(n-1)*mu^2);

			Add(result,[d,n]);
		od;
	od;

	#apply the "real roux lines detector" to see if any of the ETFs are complex
	#Note: 	It suffices to check to see if any w in E(r) other than [1,-1] has
	#	a nonzero roux parameter, since the identity of character of Gamma = E(r)
	#	maps such w to a non-real element (i.e. w itself).

	real:=true;
	for pair in c do
		if pair[2] <> 0 and not(pair[1] in [1,-1]) then
			real:=false;
		fi;
	od;
	
	Add(result,real);

	return result;
end;;


#Find all linear characters of G0ast for which the radicalization is a Higman pair
hp:=Filtered(lin, alpha -> RadIsHP(Gast,G0ast,alpha) );;

#Get the ETF parameters for each of those characters
params:=List(hp, alpha -> RadETFParams(Gast,G0ast,alpha) );

#The result shows that Sp(6,2) only acts doubly transitively on real lines